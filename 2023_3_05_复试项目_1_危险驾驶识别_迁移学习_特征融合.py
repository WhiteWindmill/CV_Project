# -*- coding: utf-8 -*-
"""2023-3-05-复试项目-1-危险驾驶识别-迁移学习-特征融合.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Uj4Nl-AM_AxILj6uWlfF3LkoySpTZyBj

# 下载kaggle数据集并解压
"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle competitions download -c state-farm-distracted-driver-detection

"""解压文件"""

!unzip /content/state-farm-distracted-driver-detection.zip

"""# 导入相关模块包"""

import tensorflow as tf
import matplotlib.pyplot as plt
import numpy as np
import os
import PIL

from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential

"""# 数据处理

## 超参数设置
"""

train_dir = '/content/imgs/train'

batch_size = 32
image_height = 180
image_weight = 180

"""## 图像预处理

### 划分训练集和验证集
"""

# 划分训练集
train_ds = tf.keras.preprocessing.image_dataset_from_directory(
    train_dir,
    labels='inferred',
    validation_split=0.2,
    subset="training",
    image_size=(image_height, image_weight),
    batch_size=batch_size,
    seed=123
)

# 划分验证集
val_ds = tf.keras.preprocessing.image_dataset_from_directory(
    train_dir,
    labels='inferred',
    validation_split=0.2,
    subset='validation',
    image_size=(image_height, image_weight),
    batch_size=batch_size,
    seed=123
)

# 打印数据集的标签
class_names = train_ds.class_names
print(class_names)
len(class_names)

"""### 查看数据是否正确"""

plt.figure(figsize=(10,10))
for images, labels in train_ds.take(1):
  for i in range(9):
    ax = plt.subplot(3, 3, i + 1)
    plt.imshow(images[i].numpy().astype("uint8"))
    plt.title(class_names[labels[i]])
    plt.axis("off")

# 查看一个批次的大小
for image_batch, labels_batch in train_ds:
  print(image_batch.shape)
  print(labels_batch.shape)
  break

num_class = len(class_names)

"""# 搭建普通CNN

## 设计网络结构
"""

model = Sequential([
    layers.experimental.preprocessing.Rescaling(1./255, input_shape=(image_height, image_weight, 3)),
    layers.Conv2D(filters=16,kernel_size=3,padding='same',activation='relu'),
    layers.MaxPooling2D(),
    layers.Conv2D(filters=32,kernel_size=3,padding='same',activation='relu'),
    layers.MaxPool2D(),
    layers.Conv2D(filters=64,kernel_size=3,padding='same',activation='relu'),
    layers.MaxPooling2D(),
    layers.Flatten(),
    layers.Dense(128,activation='relu'),
    layers.Dense(num_class)
])

"""## 打印模型的结构"""

tf.keras.utils.plot_model(model, show_shapes=True)

"""## 分配损失函数和优化器"""

model.compile(optimizer=tf.keras.optimizers.Adam(),
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy']
    
)

"""## 模型训练"""

model.summary()

epochs=3
history = model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=epochs
)

"""## 可视化训练过程"""

acc = history.history["accuracy"]
val_acc = history.history["val_accuracy"]

loss = history.history["loss"]
val_loss = history.history["val_loss"]

epoch_range = range(epochs)

plt.figure(figsize=(8, 8))
plt.subplot(1, 2, 1)
plt.plot(epoch_range, acc, label='Trannig Accuracy')
plt.plot(epoch_range, val_acc, label='Validation Accuracy')
plt.legend(loc="lower right")
plt.title('Traning and Validation Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epoch_range, loss, label='Traning Loss')
plt.plot(epoch_range, val_loss, label='Validation Accuracy')
plt.legend(loc='upper right')
plt.title("traning and Validation Loss")
plt.show()

# 出现过拟合

"""## 查看分类报告和混淆矩阵"""

# 分类报告
predict_list=[]
label_list=[]

for image_batch, labels_batch in val_ds:
  predict_score = model.predict(image_batch)
  predict_label = np.argmax(predict_score,axis=1)

  predict_list.append(predict_label)
  label_list.append(labels_batch.numpy())

predict_array = np.hstack(predict_list)
label_array = np.hstack(label_list)

from sklearn.metrics import classification_report
print(classification_report(label_array,predict_array,target_names=class_names, digits=3))

"""混淆举证"""

from sklearn.metrics import confusion_matrix
confusion_matrix(label_array, predict_array)

"""# 迁移学习模型

## EfficientNetB0

### 构建模型
"""

IMG_SHAPE = (image_height, image_weight, 3) 

base_model = tf.keras.applications.EfficientNetB0(input_shape=IMG_SHAPE,
                          include_top=False,
                          weights='imagenet')
inputs = tf.keras.Input(shape=IMG_SHAPE)
x = base_model(inputs,training=True)
x = tf.keras.layers.GlobalAveragePooling2D()(x)
x = tf.keras.layers.Dropout(0.2)(x)
outputs = tf.keras.layers.Dense(num_class)(x)

model_EfficienNetB0 = tf.keras.Model(inputs, outputs)

"""### 模型可视化"""

tf.keras.utils.plot_model(model_EfficienNetB0, show_shapes=True)

"""### 分配损失函数和优化器"""

model_EfficienNetB0.compile(optimizer='adam',
              loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics='accuracy')

"""### 模型训练"""

epochs = 2
history = model_EfficienNetB0.fit(
    train_ds,
    validation_data = val_ds,
    epochs=epochs
)

"""### 可视化训练过程"""

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss = history.history['loss']
val_loss = history.history['val_loss']

epoch_range = range(epochs)

plt.figure(figsize=(8,8))
plt.subplot(1, 2, 1)
plt.plot(epoch_range, acc, label="Traninig Accuracy")
plt.plot(epoch_range, val_acc, label="Validation Accuracy")
plt.legend(loc='lower right')
plt.title("Traning and Validation Accuracy")

plt.subplot(1, 2, 2)
plt.plot(epoch_range, loss, label="Traning Loss")
plt.plot(epoch_range, val_loss, label="Validation Loss")
plt.legend(loc='upper right')
plt.title("Training and Validation Loss")

plt.show()

"""### 查看分类报告和混淆矩阵"""

# 分类报告
predict_list=[]
label_list=[]

for image_batch, labels_batch in val_ds:
  predict_score = model_EfficienNetB0.predict(image_batch)
  predict_label = np.argmax(predict_score, axis=1)

  predict_list.append(predict_label)
  label_list.append(labels_batch.numpy())

predict_array = np.hstack(predict_list)
label_array = np.hstack(label_list)
# 得到预测矩阵和标签矩阵

from sklearn.metrics import classification_report
print(classification_report(label_array, predict_array,target_names=class_names,digits=3))

# 混淆矩阵
from sklearn.metrics import confusion_matrix
confusion_matrix(label_array, predict_array, )





"""## DenseNet121

### 构建模型
"""

IMG_SHAPE = (image_height, image_weight, 3) 

base_model = tf.keras.applications.DenseNet121(input_shape=IMG_SHAPE,
                          include_top=False,
                          weights='imagenet')
inputs = tf.keras.Input(shape=IMG_SHAPE)
x = base_model(inputs,training=True)
x = tf.keras.layers.GlobalAveragePooling2D()(x)
x = tf.keras.layers.Dropout(0.2)(x)
outputs = tf.keras.layers.Dense(num_class)(x)

model_DenseNet121 = tf.keras.Model(inputs, outputs)

"""### 模型可视化"""

tf.keras.utils.plot_model(model_DenseNet121, show_shapes=True)

"""### 分配损失函数和优化器"""

model_DenseNet121.compile(optimizer='adam',
             loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
             metrics='accuracy')

"""### 模型训练"""

epochs = 2
history = model_DenseNet121.fit(train_ds, validation_data=val_ds,epochs=epochs)

"""### 可视化训练过程"""

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss = history.history['loss']
val_loss = history.history['val_loss']

epoch_range = range(epochs)

plt.figure(figsize=(8,8))
plt.subplot(1, 2, 1)
plt.plot(epoch_range, acc, label="Traninig Accuracy")
plt.plot(epoch_range, val_acc, label="Validation Accuracy")
plt.legend(loc='lower right')
plt.title("Traning and Validation Accuracy")

plt.subplot(1, 2, 2)
plt.plot(epoch_range, loss, label="Traning Loss")
plt.plot(epoch_range, val_loss, label="Validation Loss")
plt.legend(loc='upper right')
plt.title("Training and Validation Loss")

plt.show()

"""### 查看分类报告和混淆矩阵"""

# 分类报告
predict_list=[]
label_list=[]

for image_batch, labels_batch in val_ds:
  predict_score = model_EfficienNetB0.predict(image_batch)
  predict_label = np.argmax(predict_score, axis=1)

  predict_list.append(predict_label)
  label_list.append(labels_batch.numpy())

predict_array = np.hstack(predict_list)
label_array = np.hstack(label_list)
# 得到预测矩阵和标签矩阵

from sklearn.metrics import classification_report
print(classification_report(label_array, predict_array,target_names=class_names,digits=3))

from sklearn.metrics import classification_report
print(classification_report(label_array, predict_array,target_names=class_names,digits=3))





"""# 模型融合

## 构建模型
"""

def create_EfficientNetB0_base():
  base_model = tf.keras.applications.EfficientNetB0(input_shape=IMG_SHAPE,
                            include_top=False,
                            weights='imagenet')
  inputs = tf.keras.Input(shape=IMG_SHAPE)
  x = base_model(inputs, training=True)
  x = tf.keras.layers.GlobalAveragePooling2D()(x)
  x = tf.keras.layers.Dropout(0.2)(x)
  outputs = tf.keras.layers.Dense(20)(x)
  EfficientNetB0_base = tf.keras.Model(inputs, outputs, name="EfficientNetB0")
  return EfficientNetB0_base

def create_DenseNet121_base():
  base_model = tf.keras.applications.DenseNet121(input_shape=IMG_SHAPE,
                            include_top=False,
                            weights='imagenet')
  inputs = tf.keras.Input(shape=IMG_SHAPE)
  x = base_model(inputs, training=True)
  x = tf.keras.layers.GlobalAveragePooling2D()(x)
  x = tf.keras.layers.Dropout(0.2)(x)
  outputs = tf.keras.layers.Dense(20)(x)
  DenseNet121_base = tf.keras.Model(inputs, outputs, name="DenseNet121")
  return DenseNet121_base

EfficientNetB0_base = create_EfficientNetB0_base()
DenseNet121_base = create_DenseNet121_base()

inputs_ori = tf.keras.Input(shape=IMG_SHAPE)
EfficientNetB0_feature = EfficientNetB0_base(inputs_ori)
DenseNet121_feature = DenseNet121_base(inputs_ori)

mid_feature = layers.concatenate([EfficientNetB0_feature, DenseNet121_feature])
mid_feature = tf.keras.layers.Dense(100)(mid_feature)
outputs_final = tf.keras.layers.Dense(num_class)(mid_feature)

big_model = tf.keras.Model(inputs_ori, outputs_final)

"""## 分配损失函数和优化器"""

big_model.compile(optimizer='adam',
          loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
          metrics=['accuracy'])



"""## 模型可视化"""

tf.keras.utils.plot_model(big_model, show_shapes=True)

"""## 模型训练"""

epochs = 2
history = big_model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=epochs)

"""## 可视化训练过程"""

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss = history.history['loss']
val_loss = history.history['val_loss']

epoch_range = range(epochs)

plt.figure(figsize=(8,8))
plt.subplot(1, 2, 1)
plt.plot(epoch_range, acc, label="Traninig Accuracy")
plt.plot(epoch_range, val_acc, label="Validation Accuracy")
plt.legend(loc='lower right')
plt.title("Traning and Validation Accuracy")

plt.subplot(1, 2, 2)
plt.plot(epoch_range, loss, label="Traning Loss")
plt.plot(epoch_range, val_loss, label="Validation Loss")
plt.legend(loc='upper right')
plt.title("Training and Validation Loss")

plt.show()

"""## 查看分类报告和混淆矩阵"""

# 分类报告
predict_list=[]
label_list=[]

for image_batch, labels_batch in val_ds:
  predict_score = big_model.predict(image_batch)
  predict_label = np.argmax(predict_score, axis=1)

  predict_list.append(predict_label)
  label_list.append(labels_batch.numpy())

predict_array = np.hstack(predict_list)
label_array = np.hstack(label_list)
# 得到预测矩阵和标签矩阵

from sklearn.metrics import classification_report
print(classification_report(label_array, predict_array,target_names=class_names,digits=3))

from sklearn.metrics import classification_report
print(classification_report(label_array, predict_array,target_names=class_names,digits=3))